<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TEX - Crypto</title>
  <link rel="icon" type="icon" href="./tex-logo-small.png" />
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
  
  <!-- Solana Web3 -->
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  <script src="https://unpkg.com/@orca-so/sdk@1.7.1/dist/index.iife.js"></script>
  
  <style>
    :root {
      --primary: 211, 24, 24;
      --background: 0, 0, 0;
      --primary-text: 255, 236, 236;
      --warning: 251, 191, 36;
      --interactive: 33, 42, 54;
      --module: 16, 23, 31;
    }
    
    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
      background-color: #121212;
      color: #fff;
    }
    
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 50px;
      background-color: #1a1a1a;
      border-bottom: 1px solid #333;
    }
    
    header .logo {
      font-size: 1.5rem;
      font-weight: bold;
      color: #ff4d4d;
    }
    
    header nav a {
      color: #fff;
      text-decoration: none;
      margin-left: 20px;
    }
    
    header nav a:hover {
      color: #ff4d4d;
    }
    
    main {
      padding: 40px 50px;
    }
    
    .market-table h1 {
      color: #ff4d4d;
      margin-bottom: 20px;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      background-color: #1e1e1e;
    }
    
    th, td {
      padding: 15px;
      text-align: left;
      border-bottom: 1px solid #333;
    }
    
    th {
      color: #ff4d4d;
    }
    
    td {
      color: #fff;
    }
    
    tr:hover {
      background-color: #2a2a2a;
    }
    
    .trade-button {
      padding: 8px 12px;
      background-color: #ff4d4d;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .trade-button:hover {
      background-color: #ff1a1a;
    }
    
    .loading {
      color: #888;
      font-style: italic;
    }
    
    .positive {
      color: #4CAF50;
    }
    
    .negative {
      color: #F44336;
    }
    
    footer {
      text-align: center;
      padding: 20px;
      border-top: 1px solid #333;
      margin-top: 50px;
      color: #888;
    }
    
    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    
    .modal-content {
      background-color: #1a1a1a;
      border-radius: 12px;
      width: 95%;
      max-width: 500px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      overflow: hidden;
      border: 1px solid #333;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid #333;
      background-color: #1e1e1e;
    }
    
    .modal-header h2 {
      margin: 0;
      color: #ff4d4d;
      font-size: 1.2rem;
    }
    
    .close-button {
      background: none;
      border: none;
      color: #fff;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
    }
    
    .close-button:hover {
      background-color: #333;
    }
    
    .modal-body {
      padding: 20px;
    }
    
    .form-group {
      margin-bottom: 15px;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 5px;
      color: #ccc;
    }
    
    .form-control {
      width: 100%;
      padding: 10px;
      background-color: #2a2a2a;
      border: 1px solid #444;
      border-radius: 4px;
      color: #fff;
      box-sizing: border-box;
    }
    
    .form-control:focus {
      outline: none;
      border-color: #ff4d4d;
    }
    
    .swap-info {
      background-color: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      font-size: 0.9rem;
    }
    
    .swap-info div {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
    }
    
    .swap-button {
      width: 100%;
      padding: 12px;
      background-color: #ff4d4d;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
    }
    
    .swap-button:hover {
      background-color: #ff1a1a;
    }
    
    .swap-button:disabled {
      background-color: #666;
      cursor: not-allowed;
    }
    
    .error-message {
      color: #ff4d4d;
      margin-top: 10px;
      text-align: center;
    }
    
    .success-message {
      color: #4CAF50;
      margin-top: 10px;
      text-align: center;
    }
    
    .wallet-status {
      padding: 10px;
      background-color: #2a2a2a;
      border-radius: 4px;
      margin-bottom: 15px;
      font-size: 0.9rem;
    }
    
    .connect-wallet {
      width: 100%;
      padding: 12px;
      background-color: #4CAF50;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-bottom: 15px;
    }
    
    .connect-wallet:hover {
      background-color: #45a049;
    }
  </style>
</head>
<body>
  <header>
    <div class="logo">TEX</div>
    <nav>
      <a href="https://tex-us.github.io/home/">Home</a>
      <a href="https://tex-us.github.io/crypto/">Crypto</a>
      <a href="https://tex-us.github.io/stocks/">Stocks</a>
      <a href="https://tex-us.github.io/contribute/">Contribute</a>
    </nav>
  </header>
  
  <main>
    <div class="market-table">
      <h1>Crypto</h1>
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>Symbol</th>
            <th>Price</th>
            <th>24h Change</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody id="crypto-table-body">
          <!-- Table rows will be populated by JavaScript -->
        </tbody>
      </table>
    </div>
  </main>
  
  <!-- Orca Trade Modal -->
  <div id="orca-modal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Trade Crypto</h2>
        <button class="close-button" onclick="closeOrcaModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div id="wallet-status" class="wallet-status">
          Wallet: Not Connected
        </div>
        <button id="connect-wallet" class="connect-wallet">Connect Phantom Wallet</button>
        
        <div class="form-group">
          <label for="input-amount">Input Amount (SOL)</label>
          <input type="number" id="input-amount" class="form-control" placeholder="0.0" min="0" step="0.001" onchange="calculateOutputAmount()" disabled>
        </div>
        
        <div class="form-group">
          <label for="output-token">Output Token</label>
          <input type="text" id="output-token" class="form-control" readonly>
        </div>
        
        <div class="swap-info" id="swap-info">
          <div>
            <span>Estimated Output:</span>
            <span id="estimated-output">-</span>
          </div>
          <div>
            <span>Price Impact:</span>
            <span id="price-impact">-</span>
          </div>
          <div>
            <span>Minimum Received:</span>
            <span id="min-received">-</span>
          </div>
        </div>
        
        <button id="swap-button" class="swap-button" onclick="executeSwap()" disabled>Swap</button>
        
        <div id="error-message" class="error-message"></div>
        <div id="success-message" class="success-message"></div>
      </div>
    </div>
  </div>
  
  <footer>
    <p>&copy; 2023 TEX. All rights reserved.</p>
  </footer>
  
  <script>
    // Token configuration with mints
    const TOKENS = [
      { 
        name: "USD1", 
        symbol: "USD1", 
        coinId: "usd1-wlfi", 
        mint: "USD1ttGY1N17NEEHLmELoaybftRBUSErhqYiQzvEmuB" 
      },
      { 
        name: "Bitcoin", 
        symbol: "BTC", 
        coinId: "bitcoin", 
        mint: "3NZ9JMVBmGAqocybic2c7LQCJScmgsAZ6vQqTDzcqmJh" 
      },
      { 
        name: "Ethereum", 
        symbol: "ETH", 
        coinId: "ethereum", 
        mint: "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs" 
      },
      { 
        name: "Solana", 
        symbol: "SOL", 
        coinId: "solana", 
        mint: "So11111111111111111111111111111111111111112" 
      },
      { 
        name: "Tron", 
        symbol: "TRX", 
        coinId: "tron", 
        mint: "GbbesPbaYh5uiAZSYNXTc7w9jty1rpg3P9L4JeN4LkKc" 
      },
      { 
        name: "Binance Coin", 
        symbol: "BNB", 
        coinId: "binancecoin", 
        mint: "9gP2kCy3wA1ctvYWQk75guqXuHfrEomqydHLtcTCqiLa" 
      },
      { 
        name: "Shiba Inu", 
        symbol: "SHIB", 
        coinId: "shiba-inu", 
        mint: "CiKu4eHsVrc1eueVQeHn7qhXTcVu95gSQmBpX4utjL9z" 
      },
      { 
        name: "Avalanche", 
        symbol: "AVAX", 
        coinId: "avalanche-2", 
        mint: "AUrMpCDYYcPuHhyNX8gEEqbmDPFUpBpHrNW3vPeCFn5Z" 
      },
      { 
        name: "Zcash", 
        symbol: "ZEC", 
        coinId: "zcash", 
        mint: "A7bdiYdS5GjqGFtxf17ppRHtDKPkkRqbKtR27dxvQXaS" 
      },
      { 
        name: "Hyperliquid", 
        symbol: "HYPE", 
        coinId: "hyperliquid",
        mint: "98sMhvDwXj1RQi5c5Mndm3vPe9cBqPrbLaufMXFNMh5g" 
      },
      { 
        name: "World Liberty Financial Token",
        symbol: "WLFI", 
        coinId: "world-liberty-financial",
        mint: "WLFinEv6ypjkczcS83FZqFpgFZYwQXutRbxGe7oC16g" 
      },
      { 
        name: "Official Trump",
        symbol: "TRUMP", 
        coinId: "official-trump",
        mint: "6p6xgHyF7AeE6TZkSmFsko444wqoP15icUSqi2jfGiPN" 
      },
      { 
        name: "Popcat",
        symbol: "POPCAT", 
        coinId: "popcat",
        mint: "7GCihgDB8fe6KNjn2MYtkzZcRjQy3t9GHdC8uHYmW2hr" 
      },
      { 
        name: "Bonk.fun",
        symbol: "BONK", 
        coinId: "bonk",
        mint: "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263" 
      },
      { 
        name: "Useless Coin",
        symbol: "USELESS", 
        coinId: "useless-3",
        mint: "Dz9mQ9NzkBcCsuGPFJ3r1bS4wgqKMHBPiVuniW8Mbonk" 
      }
    ];

    // CoinGecko API configuration
    const COINGECKO_API_URL = 'https://api.coingecko.com/api/v3/simple/price';
    
    // Orca SDK and Solana connection
    let orca;
    let connection;
    let currentOutputMint;
    let currentTokenSymbol;
    let wallet = null;
    
    // Initialize Orca SDK
    async function initializeOrca() {
      try {
        console.log("Initializing Orca SDK...");
        
        // Initialize connection to Solana
        connection = new solanaWeb3.Connection(
          "https://sly-magical-choice.solana-mainnet.quiknode.pro/9737d38bbddec665ec0d50c788199a9120a0c8bc/",
          "confirmed"
        );
        
        // Initialize Orca SDK
        orca = Orca.SDK.load({ connection });
        console.log("Orca SDK initialized successfully");
        
        // Check for existing wallet connection
        checkWalletConnection();
        
      } catch (error) {
        console.error("Failed to initialize Orca SDK:", error);
        showError("Failed to initialize trading functionality");
      }
    }
    
    // Check if wallet is already connected
    function checkWalletConnection() {
      if (window.solana && window.solana.isPhantom && window.solana.isConnected) {
        wallet = window.solana;
        updateWalletStatus();
      }
    }
    
    // Connect to Phantom wallet
    async function connectWallet() {
      try {
        if (!window.solana || !window.solana.isPhantom) {
          showError("Please install Phantom wallet to trade");
          return;
        }
        
        wallet = window.solana;
        await wallet.connect();
        updateWalletStatus();
        showSuccess("Wallet connected successfully!");
        
        // Enable input field
        document.getElementById('input-amount').disabled = false;
        
      } catch (error) {
        console.error("Failed to connect wallet:", error);
        showError("Failed to connect wallet");
      }
    }
    
    // Update wallet status display
    function updateWalletStatus() {
      const statusElement = document.getElementById('wallet-status');
      if (wallet && wallet.publicKey) {
        const shortAddress = wallet.publicKey.toString().slice(0, 4) + '...' + wallet.publicKey.toString().slice(-4);
        statusElement.textContent = `Wallet: ${shortAddress}`;
        statusElement.style.color = '#4CAF50';
      } else {
        statusElement.textContent = 'Wallet: Not Connected';
        statusElement.style.color = '#ff4d4d';
      }
    }
    
    // Initialize table with tokens
    function initializeTable() {
      const tableBody = document.getElementById('crypto-table-body');
      tableBody.innerHTML = '';
      
      TOKENS.forEach(token => {
        const row = document.createElement('tr');
        row.setAttribute('data-coin', token.coinId || token.symbol);
        row.innerHTML = `
          <td>${token.name}</td>
          <td>${token.symbol}</td>
          <td class="price loading">Loading...</td>
          <td class="change loading">Loading...</td>
          <td><button class="trade-button" onclick="openOrcaModal('${token.mint}', '${token.symbol}', '${token.name}')">Trade</button></td>
        `;
        tableBody.appendChild(row);
      });
    }
    
    // Split tokens into chunks for staggered fetching
    function chunkArray(array, chunkSize) {
      const chunks = [];
      for (let i = 0; i < array.length; i += chunkSize) {
        chunks.push(array.slice(i, i + chunkSize));
      }
      return chunks;
    }
    
    // Fetch prices in batches with delays
    async function fetchPricesInBatches() {
      // Only fetch tokens that have CoinGecko IDs
      const tokensWithCoinIds = TOKENS.filter(token => token.coinId !== null);
      
      // Split into smaller batches (5 tokens per batch)
      const batches = chunkArray(tokensWithCoinIds, 5);
      
      for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        await fetchBatchPrices(batch);
        
        if (i < batches.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 5000));
        }
      }
      
      // Set tokens without CoinGecko IDs to N/A
      setNonGeckoTokensToNA();
    }
    
    // Fetch a single batch of prices
    async function fetchBatchPrices(batch) {
      try {
        const coinIds = batch.map(token => token.coinId).join(',');
        console.log(`Fetching batch: ${coinIds}`);
        
        const response = await fetch(
          `${COINGECKO_API_URL}?ids=${coinIds}&vs_currencies=usd&include_24hr_change=true`
        );
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        updateTableWithData(data, batch);
        
      } catch (error) {
        console.error('Error fetching batch prices:', error);
        setBatchToError(batch);
      }
    }
    
    // Update table with data from a batch
    function updateTableWithData(data, batch) {
      batch.forEach(token => {
        const row = document.querySelector(`tr[data-coin="${token.coinId}"]`);
        if (row && data[token.coinId]) {
          const priceCell = row.querySelector('.price');
          const changeCell = row.querySelector('.change');
          
          // Format price
          const price = data[token.coinId].usd;
          const priceFormatted = price < 0.01 
            ? `$${price.toFixed(6)}` 
            : `$${price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 6 })}`;
          
          priceCell.textContent = priceFormatted;
          priceCell.className = 'price';
          
          // Format 24h change
          const change = data[token.coinId].usd_24h_change;
          if (change !== undefined) {
            const changeClass = change >= 0 ? 'positive' : 'negative';
            const changeSymbol = change >= 0 ? '+' : '';
            changeCell.textContent = `${changeSymbol}${change.toFixed(2)}%`;
            changeCell.className = `change ${changeClass}`;
          } else {
            changeCell.textContent = 'N/A';
            changeCell.className = 'change';
          }
        }
      });
    }
    
    // Set batch to error state
    function setBatchToError(batch) {
      batch.forEach(token => {
        const row = document.querySelector(`tr[data-coin="${token.coinId}"]`);
        if (row) {
          const priceCell = row.querySelector('.price');
          const changeCell = row.querySelector('.change');
          
          priceCell.textContent = 'Error';
          priceCell.className = 'price negative';
          changeCell.textContent = 'Error';
          changeCell.className = 'change negative';
        }
      });
    }
    
    // Set tokens without CoinGecko IDs to N/A
    function setNonGeckoTokensToNA() {
      const tokensWithoutCoinIds = TOKENS.filter(token => token.coinId === null);
      
      tokensWithoutCoinIds.forEach(token => {
        const row = document.querySelector(`tr[data-coin="${token.symbol}"]`);
        if (row) {
          const priceCell = row.querySelector('.price');
          const changeCell = row.querySelector('.change');
          
          priceCell.textContent = 'N/A';
          priceCell.className = 'price';
          changeCell.textContent = 'N/A';
          changeCell.className = 'change';
        }
      });
    }
    
    // Auto-refresh prices every 60 seconds
    function startPriceUpdates() {
      fetchPricesInBatches(); // Initial fetch
      setInterval(fetchPricesInBatches, 60000); // Update every 60 seconds
    }
    
    // Open Orca trade modal
    function openOrcaModal(outputMint, tokenSymbol, tokenName) {
      currentOutputMint = outputMint;
      currentTokenSymbol = tokenSymbol;
      
      // Reset form
      document.getElementById('input-amount').value = '';
      document.getElementById('output-token').value = `${tokenName} (${tokenSymbol})`;
      clearSwapInfo();
      document.getElementById('swap-button').disabled = true;
      clearMessages();
      
      document.getElementById('orca-modal').style.display = 'flex';
    }
    
    // Close Orca modal
    function closeOrcaModal() {
      document.getElementById('orca-modal').style.display = 'none';
    }
    
    // Calculate output amount based on input
    async function calculateOutputAmount() {
      const inputAmount = parseFloat(document.getElementById('input-amount').value);
      
      if (!inputAmount || inputAmount <= 0) {
        document.getElementById('swap-button').disabled = true;
        clearSwapInfo();
        return;
      }
      
      if (!wallet) {
        showError("Please connect your wallet first");
        return;
      }
      
      try {
        console.log("Calculating swap for:", inputAmount, "SOL to", currentTokenSymbol);
        
        // Get token mints
        const solMint = new solanaWeb3.PublicKey("So11111111111111111111111111111111111111112");
        const outputMint = new solanaWeb3.PublicKey(currentOutputMint);
        
        // Get Orca instance
        const orcaInstance = await orca;
        
        // Get token objects
        const solToken = orcaInstance.getToken(solMint);
        const outputToken = orcaInstance.getToken(outputMint);
        
        // Get quote for swap
        const quote = await orcaInstance.getQuote(
          solToken,
          outputToken,
          inputAmount
        );
        
        console.log("Quote received:", quote);
        
        // Update UI with quote information
        document.getElementById('estimated-output').textContent = `${quote.getExpectedOutputAmount().toFixed(6)} ${currentTokenSymbol}`;
        document.getElementById('price-impact').textContent = `${(quote.getPriceImpact() * 100).toFixed(2)}%`;
        document.getElementById('min-received').textContent = `${quote.getMinOutputAmount().toFixed(6)} ${currentTokenSymbol}`;
        
        // Enable swap button
        document.getElementById('swap-button').disabled = false;
        clearMessages();
        
      } catch (error) {
        console.error("Error calculating swap:", error);
        showError(`Failed to calculate swap: ${error.message}`);
        document.getElementById('swap-button').disabled = true;
      }
    }
    
    // Execute the swap
    async function executeSwap() {
      const inputAmount = parseFloat(document.getElementById('input-amount').value);
      
      if (!inputAmount || inputAmount <= 0) {
        showError("Please enter a valid amount");
        return;
      }
      
      if (!wallet || !wallet.publicKey) {
        showError("Please connect your wallet first");
        return;
      }
      
      try {
        // Get token mints
        const solMint = new solanaWeb3.PublicKey("So11111111111111111111111111111111111111112");
        const outputMint = new solanaWeb3.PublicKey(currentOutputMint);
        
        // Get Orca instance
        const orcaInstance = await orca;
        
        // Get token objects
        const solToken = orcaInstance.getToken(solMint);
        const outputToken = orcaInstance.getToken(outputMint);
        
        // Get quote for swap
        const quote = await orcaInstance.getQuote(
          solToken,
          outputToken,
          inputAmount
        );
        
        // Execute swap
        const swapPayload = await orcaInstance.swap({
          quote,
          userPublicKey: wallet.publicKey,
          slippage: 1.0 // 1% slippage
        });
        
        // Send transaction
        const transaction = swapPayload.transaction;
        const { blockhash } = await connection.getRecentBlockhash();
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = wallet.publicKey;
        
        // Request signature from wallet
        const signedTransaction = await wallet.signTransaction(transaction);
        const signature = await connection.sendRawTransaction(signedTransaction.serialize());
        
        // Confirm transaction
        const confirmation = await connection.confirmTransaction(signature, 'confirmed');
        
        if (confirmation.value.err) {
          throw new Error("Transaction failed");
        }
        
        showSuccess(`Swap completed! Transaction: ${signature}`);
        
      } catch (error) {
        console.error("Error executing swap:", error);
        showError(`Failed to execute swap: ${error.message}`);
      }
    }
    
    // Helper functions for UI
    function clearSwapInfo() {
      document.getElementById('estimated-output').textContent = '-';
      document.getElementById('price-impact').textContent = '-';
      document.getElementById('min-received').textContent = '-';
    }
    
    function showError(message) {
      document.getElementById('error-message').textContent = message;
      document.getElementById('success-message').textContent = '';
    }
    
    function showSuccess(message) {
      document.getElementById('success-message').textContent = message;
      document.getElementById('error-message').textContent = '';
    }
    
    function clearMessages() {
      document.getElementById('error-message').textContent = '';
      document.getElementById('success-message').textContent = '';
    }
    
    // Close modal when clicking outside
    window.addEventListener('click', function(event) {
      const modal = document.getElementById('orca-modal');
      if (event.target === modal) {
        closeOrcaModal();
      }
    });
    
    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', async function() {
      initializeTable();
      startPriceUpdates();
      await initializeOrca();
      
      // Add event listener for connect wallet button
      document.getElementById('connect-wallet').addEventListener('click', connectWallet);
    });
  </script>
</body>
</html>
